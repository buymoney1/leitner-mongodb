// lib/prisma.ts
import { PrismaClient } from '@prisma/client'

// تعریف انواع برای مدل‌ها
type ModelName = keyof PrismaClient

// قوانین اعتبارسنجی برای هر مدل
interface ValidationRules {
  requiredFields?: string[]
  dateFields?: string[] // فیلدهایی که باید Date باشند
  numberFields?: string[] // فیلدهایی که باید number باشند
  booleanFields?: string[] // فیلدهایی که باید boolean باشند
  stringFields?: string[] // فیلدهایی که باید string باشند
  forbiddenFields?: string[] // فیلدهایی که نباید از کلاینت بیایند
  autoGeneratedFields?: string[] // فیلدهایی که سیستم خودش می‌سازد
}

// قوانین برای هر مدل
const MODEL_RULES: Record<string, ValidationRules> = {
  // ============ User ============
  User: {
    requiredFields: [],
    dateFields: ['emailVerified', 'lastReviewNotificationAt', 'lastNotificationAt'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt', 'role'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt', 'role']
  },
  
  // ============ Account (NextAuth) ============
  Account: {
    requiredFields: ['userId', 'type', 'provider', 'providerAccountId'],
    numberFields: ['expires_at'],
    autoGeneratedFields: ['id'],
    forbiddenFields: ['id']
  },
  
  // ============ Session (NextAuth) ============
  Session: {
    requiredFields: ['sessionToken', 'userId', 'expires'],
    dateFields: ['expires'],
    autoGeneratedFields: ['id'],
    forbiddenFields: ['id']
  },
  
  // ============ ActivityTracking ============
  ActivityTracking: {
    requiredFields: ['userId', 'activityType', 'duration'],
    numberFields: ['duration'],
    stringFields: ['activityType', 'pathname'],
    dateFields: ['registeredAt'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt', 'isRegistered'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt', 'isRegistered']
  },
  
  // ============ DailyActivity ============
  DailyActivity: {
    requiredFields: ['userId', 'date'],
    dateFields: ['date', 'completedAt'],
    numberFields: ['progress'],
    booleanFields: ['videoWatched', 'podcastListened', 'wordsReviewed', 'articleRead', 'songListened'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ Book ============
  Book: {
    requiredFields: ['title', 'userId'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ Card ============
  Card: {
    requiredFields: ['front', 'back'],
    numberFields: ['boxNumber'],
    dateFields: ['lastReviewedAt', 'nextReviewAt'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ Review ============
  Review: {
    requiredFields: ['isCorrect', 'cardId', 'userId'],
    booleanFields: ['isCorrect'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ Video ============
  Video: {
    requiredFields: ['title', 'videoUrl', 'level'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ Podcast ============
  Podcast: {
    requiredFields: ['title', 'audioUrl', 'level'],
    numberFields: ['duration'],
    booleanFields: ['isPublished'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ Article ============
  Article: {
    requiredFields: ['title', 'content', 'level'],
    numberFields: ['readingTime'],
    booleanFields: ['isPublished'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ Song ============
  Song: {
    requiredFields: ['title', 'artist', 'duration', 'audioUrl', 'lyrics'],
    numberFields: ['duration'],
    booleanFields: ['isPublished'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  },
  
  // ============ NotificationLog ============
  NotificationLog: {
    requiredFields: ['userId', 'title', 'body'],
    dateFields: ['sentAt'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt', 'status'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt', 'status']
  },
  
  // ============ PushSubscription ============
  PushSubscription: {
    requiredFields: ['userId', 'endpoint', 'keys'],
    dateFields: ['expiresAt'],
    autoGeneratedFields: ['id', 'createdAt', 'updatedAt'],
    forbiddenFields: ['id', 'createdAt', 'updatedAt']
  }
}

class SafePrisma {
  private prisma: PrismaClient
  private static instance: SafePrisma
  
  private constructor() {
    this.prisma = new PrismaClient({
      log: process.env.NODE_ENV === 'development' 
        ? ['query', 'error', 'warn'] 
        : ['error']
    })
  }
  
  static getInstance(): SafePrisma {
    if (!SafePrisma.instance) {
      SafePrisma.instance = new SafePrisma()
    }
    return SafePrisma.instance
  }
  
  // ============ متدهای اصلی ============
  
  /**
   * ایجاد رکورد جدید با اعتبارسنجی کامل
   */
  async create<T extends ModelName>(
    model: T, 
    data: any,
    options: {
      userId?: string // برای اضافه کردن userId از session
      skipValidation?: boolean // فقط برای موارد خاص
    } = {}
  ) {
    // اعتبارسنجی
    if (!options.skipValidation) {
      const validation = this.validateData(model as string, data, 'create')
      if (!validation.isValid) {
        throw new Error(`Validation failed for ${model}: ${validation.errors.join(', ')}`)
      }
    }
    
    // پاکسازی داده‌ها
    const sanitizedData = this.sanitizeData(model as string, data, 'create', options.userId)
    
    // ایجاد رکورد
    return await this.prisma[model].create({
      data: sanitizedData
    })
  }
  
  /**
   * آپدیت رکورد با اعتبارسنجی کامل
   */
  async update<T extends ModelName>(
    model: T,
    where: any,
    data: any,
    options: {
      skipValidation?: boolean
    } = {}
  ) {
    // اعتبارسنجی
    if (!options.skipValidation) {
      const validation = this.validateData(model as string, data, 'update')
      if (!validation.isValid) {
        throw new Error(`Validation failed for ${model}: ${validation.errors.join(', ')}`)
      }
    }
    
    // پاکسازی داده‌ها
    const sanitizedData = this.sanitizeData(model as string, data, 'update')
    
    // آپدیت رکورد
    return await this.prisma[model].update({
      where,
      data: sanitizedData
    })
  }
  
  /**
   * اعتبارسنجی داده‌ها
   */
  private validateData(
    model: string, 
    data: any, 
    action: 'create' | 'update'
  ): {
    isValid: boolean
    errors: string[]
  } {
    const errors: string[] = []
    const rules = MODEL_RULES[model] || {}
    
    // برای create، فیلدهای اجباری را چک کن
    if (action === 'create' && rules.requiredFields) {
      for (const field of rules.requiredFields) {
        if (data[field] === undefined || data[field] === null || data[field] === '') {
          errors.push(`فیلد ${field} الزامی است`)
        }
      }
    }
    
    // چک کردن نوع داده‌ها
    Object.entries(data).forEach(([field, value]) => {
      // فیلدهای ممنوعه
      if (rules.forbiddenFields?.includes(field)) {
        errors.push(`فیلد ${field} نباید ارسال شود`)
        return
      }
      
      // اعتبارسنجی بر اساس نوع
      if (rules.dateFields?.includes(field) && value !== undefined && value !== null) {
        if (!this.isValidDate(value)) {
          errors.push(`فیلد ${field} باید تاریخ معتبر باشد`)
        }
      }
      
      if (rules.numberFields?.includes(field) && value !== undefined && value !== null) {
        if (typeof value !== 'number' || isNaN(value)) {
          errors.push(`فیلد ${field} باید عدد باشد`)
        }
      }
      
      if (rules.booleanFields?.includes(field) && value !== undefined && value !== null) {
        if (typeof value !== 'boolean') {
          errors.push(`فیلد ${field} باید boolean باشد`)
        }
      }
      
      if (rules.stringFields?.includes(field) && value !== undefined && value !== null) {
        if (typeof value !== 'string') {
          errors.push(`فیلد ${field} باید رشته باشد`)
        }
      }
    })
    
    return {
      isValid: errors.length === 0,
      errors
    }
  }
  
  /**
   * پاکسازی داده‌ها قبل از ذخیره
   */
  private sanitizeData(
    model: string,
    data: any,
    action: 'create' | 'update',
    userId?: string
  ): any {
    const sanitized = { ...data }
    const rules = MODEL_RULES[model] || {}
    
    // حذف فیلدهای ممنوعه
    if (rules.forbiddenFields) {
      rules.forbiddenFields.forEach(field => {
        delete sanitized[field]
      })
    }
    
    // حذف فیلدهای auto-generated
    if (rules.autoGeneratedFields) {
      rules.autoGeneratedFields.forEach(field => {
        delete sanitized[field]
      })
    }
    
    // اضافه کردن userId اگر وجود دارد
    if (userId && model !== 'User') {
      // بررسی آیا مدل فیلد userId دارد
      const hasUserIdField = 
        model === 'Account' || 
        model === 'Session' || 
        model === 'ActivityTracking' || 
        model === 'DailyActivity' || 
        model === 'Book' || 
        model === 'Card' || 
        model === 'Review' || 
        model === 'NotificationLog' || 
        model === 'PushSubscription'
      
      if (hasUserIdField) {
        sanitized.userId = userId
      }
    }
    
    // تبدیل تاریخ‌های رشته‌ای به Date
    if (rules.dateFields) {
      rules.dateFields.forEach(field => {
        if (sanitized[field] && typeof sanitized[field] === 'string') {
          try {
            sanitized[field] = new Date(sanitized[field])
          } catch (error) {
            delete sanitized[field] // اگر تبدیل نشد، حذف کن
          }
        }
      })
    }
    
    // تبدیل عددهای رشته‌ای به number
    if (rules.numberFields) {
      rules.numberFields.forEach(field => {
        if (sanitized[field] && typeof sanitized[field] === 'string') {
          const num = parseFloat(sanitized[field])
          if (!isNaN(num)) {
            sanitized[field] = num
          } else {
            delete sanitized[field]
          }
        }
      })
    }
    
    // تبدیل boolean‌های رشته‌ای
    if (rules.booleanFields) {
      rules.booleanFields.forEach(field => {
        if (sanitized[field] !== undefined && sanitized[field] !== null) {
          if (typeof sanitized[field] === 'string') {
            sanitized[field] = sanitized[field].toLowerCase() === 'true'
          }
        }
      })
    }
    
    return sanitized
  }
  
  /**
   * بررسی معتبر بودن تاریخ
   */
  private isValidDate(value: any): boolean {
    if (value instanceof Date) {
      return !isNaN(value.getTime())
    }
    
    if (typeof value === 'string') {
      const date = new Date(value)
      return !isNaN(date.getTime())
    }
    
    if (typeof value === 'number') {
      const date = new Date(value)
      return !isNaN(date.getTime())
    }
    
    return false
  }
  
  /**
   * دسترسی مستقیم به Prisma (فقط برای عملیات خواندن)
   */
  get client() {
    return this.prisma
  }
  
  /**
   * ایجاد مدل جدید به صورت پویا
   * (برای APIهای جدید که هنوز در MODEL_RULES تعریف نشده‌اند)
   */
  defineModelRules(model: string, rules: ValidationRules) {
    MODEL_RULES[model] = rules
  }
}

// ایجاد singleton instance
export const prisma = SafePrisma.getInstance()

// Type-safe wrapper برای استفاده آسان
export const db = {
  // برای عملیات create
  create: prisma.create.bind(prisma),
  
  // برای عملیات update
  update: prisma.update.bind(prisma),
  
  // برای عملیات read (از client اصلی استفاده کن)
  findMany: (model: string, args?: any) => prisma.client[model].findMany(args),
  findFirst: (model: string, args?: any) => prisma.client[model].findFirst(args),
  findUnique: (model: string, args?: any) => prisma.client[model].findUnique(args),
  count: (model: string, args?: any) => prisma.client[model].count(args),
  
  // برای عملیات delete
  delete: (model: string, args?: any) => prisma.client[model].delete(args),
  deleteMany: (model: string, args?: any) => prisma.client[model].deleteMany(args),
  
  // تعریف مدل جدید
  defineModel: prisma.defineModelRules.bind(prisma)
}